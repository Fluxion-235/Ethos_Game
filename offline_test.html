<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Precision - Final Version (Updated)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&family=Press+Start+2P&family=Roboto+Mono:wght@700&display=swap');

        :root {
            --team-a-color: #f04d5d;
            --team-b-color: #00b8d4;
            --gem-color: #f7b733;
            --bg-deep: #12121c;
            --bg-medium: #1a1a2e;
            --bg-light: #16213e;
            --card-bg: rgba(22, 33, 62, 0.85);
            --text-light: #e0fbfc;
            --text-medium: #9fb3c8;
            --text-dark: #627d98;
            --font-main: 'Poppins', sans-serif;
            --font-title: 'Press Start 2P', cursive;
            --font-mono: 'Roboto Mono', monospace;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg-deep);
            color: var(--text-light);
            font-family: var(--font-main);
            overflow: hidden;
            /* Responsive base font size */
            font-size: clamp(14px, 1.5vmin, 16px);
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        canvas {
            background-color: #2c5d3d; /* Darker green for less eye strain */
            cursor: none;
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- Modern UI System --- */

        .screen {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(18, 18, 28, 0.7);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            display: none; flex-direction: column;
            align-items: center; justify-content: center;
            text-align: center;
            padding: 1rem;
            z-index: 10;
            animation: fadeIn 0.6s cubic-bezier(0.25, 1, 0.5, 1);
            overflow-y: auto; /* Allow scrolling on small screens */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        .screen.active {
            display: flex;
        }

        .ui-card {
            background: var(--card-bg);
            padding: clamp(2rem, 5vw, 3rem);
            border-radius: 20px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 100%;
            max-width: 600px;
        }

        /* --- Typography --- */

        h1 {
            font-family: var(--font-title);
            font-size: clamp(2em, 5vw, 3.5em); /* Responsive font size */
            margin: 0 0 10px 0;
            background: linear-gradient(45deg, var(--gem-color), #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(247, 183, 51, 0.3);
        }
        h2 {
            font-family: var(--font-main);
            font-weight: 700;
            color: var(--text-light);
            font-size: clamp(1.5em, 4vw, 2em); /* Responsive font size */
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        h3 {
            font-family: var(--font-main);
            font-weight: 600;
            font-size: clamp(1.2em, 3vw, 1.4em); /* Responsive font size */
            margin: 1rem 0 0.8rem 0;
            color: var(--gem-color);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        p {
            font-size: clamp(0.9em, 2vw, 1.1em); /* Responsive font size */
            line-height: 1.6em;
            color: var(--text-medium);
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        /* --- Interactive Elements --- */

        button {
            background: linear-gradient(45deg, var(--team-b-color), #008c9e);
            color: white;
            border: none;
            padding: clamp(12px, 2vh, 15px) clamp(25px, 4vw, 35px); /* Responsive padding */
            font-size: clamp(0.9em, 2.5vw, 1.1em); /* Responsive font size */
            font-family: var(--font-main);
            font-weight: 700;
            cursor: pointer;
            margin: 10px;
            transition: all 0.2s ease-in-out;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 184, 212, 0.2), inset 0 -2px 0 rgba(0,0,0,0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 184, 212, 0.4), inset 0 -2px 0 rgba(0,0,0,0.3);
            filter: brightness(1.1);
        }
        button:active {
            transform: translateY(-1px);
            box-shadow: 0 2px 10px rgba(0, 184, 212, 0.4), inset 0 -1px 0 rgba(0,0,0,0.3);
            filter: brightness(1);
        }
        button:disabled {
            background: var(--text-dark);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            filter: brightness(0.8);
        }

        input[type="text"] {
            padding: 15px 20px;
            font-size: 1.2em;
            margin-bottom: 20px;
            width: 100%; /* CHANGED: Use full width of container */
            max-width: 350px; /* CHANGED: Set a max-width */
            text-align: center;
            background: var(--bg-medium);
            color: var(--text-light);
            border: 2px solid var(--bg-light);
            border-radius: 12px;
            font-family: var(--font-main);
            font-weight: 600;
            transition: all 0.2s ease;
        }
        input:focus {
            outline: none;
            border-color: var(--gem-color);
            box-shadow: 0 0 15px rgba(247, 183, 51, 0.5);
        }

        /* --- Start Screen --- */

        #start-screen {
            background: radial-gradient(ellipse at bottom, var(--bg-light) 0%, var(--bg-deep) 100%);
        }
        .bg-characters { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; z-index: -1; opacity: 0.2; }
        .character-silhouette {
            position: absolute; bottom: -50px;
            font-size: 300px; color: rgba(0,0,0,0.5);
            animation: slide 80s linear infinite alternate;
        }
        .char1 { left: 5%; animation-duration: 75s; }
        .char2 { left: 25%; animation-duration: 85s; animation-delay: -10s; font-size: 350px; }
        .char3 { left: 45%; animation-duration: 70s; animation-delay: -20s; }
        .char4 { left: 65%; animation-duration: 90s; animation-delay: -30s; font-size: 320px; }
        .char5 { left: 85%; animation-duration: 80s; animation-delay: -40s; }
        @keyframes slide { from { transform: translateY(0); } to { transform: translateY(-100px); } }

        /* --- Lobby Screen --- */
        #lobby-container { display: flex; justify-content: center; gap: 2rem; width: 100%; max-width: 1200px; flex-wrap: wrap; }
        .team-panel {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 1.5rem;
            width: 100%; /* CHANGED: Full width for small screens */
            max-width: 450px; /* CHANGED: Set a max-width */
            min-width: 300px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4), inset 0 5px 0 0 var(--color, transparent);
            display: flex; flex-direction: column;
            transition: all 0.3s ease;
        }
        .team-panel.team-a { --color: var(--team-a-color); }
        .team-panel.team-b { --color: var(--team-b-color); }
        .team-panel h3 { font-size: 1.8em; margin: 0 0 20px 0; font-weight: 700; }
        .team-panel.team-a h3 { color: var(--team-a-color); }
        .team-panel.team-b h3 { color: var(--team-b-color); }
        .player-list { list-style: none; padding: 0; margin: 0 0 20px 0; min-height: 250px; max-height: 40vh; overflow-y: auto; }
        .player-list li {
            background: var(--bg-medium); padding: 12px 18px; margin-bottom: 8px;
            border-radius: 8px; font-size: 1.1em; display: flex;
            justify-content: space-between; align-items: center;
            font-weight: 600; transition: all 0.2s ease;
            border-left: 4px solid transparent;
        }
        .player-list li.local-player { border-left-color: var(--gem-color); font-weight: 700; }
        .player-list li.can-vote:hover { background-color: var(--gem-color); cursor: pointer; color: var(--bg-deep); transform: translateX(5px); }
        .team-actions { margin-top: auto; padding-top: 20px; border-top: 1px solid var(--bg-light); }
        .captain-actions { margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--gem-color); }
        .captain-actions input { width: 100%; margin-bottom: 10px; font-size: 1em; }
        .captain-actions button { width: 100%; padding: 10px; font-size: 0.9em; }

        /* --- LOADOUT UI STYLES --- */
        #loadout-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 2rem;
            width: 100%;
            max-width: 1400px;
            flex-wrap: wrap;
        }
        .loadout-panel {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 1.5rem;
            width: 100%;
            max-width: 400px;
            min-width: 300px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex; flex-direction: column;
        }
        .loadout-panel h3 { margin-top: 0; }
        .loadout-panel .card-container {
            max-height: 50vh;
            overflow-y: auto;
            padding-right: 10px;
        }
        .selection-card {
            background: var(--bg-light); border-radius: 12px; padding: 15px;
            cursor: pointer; transition: all 0.2s ease-in-out;
            border: 2px solid var(--bg-light); width: 100%;
            display: flex; flex-direction: row; align-items: center; text-align: left; gap: 15px;
            margin-bottom: 10px;
        }
        .selection-card:hover {
            transform: translateY(-5px);
            border-color: var(--text-medium);
        }
        .selection-card.selected {
            transform: translateY(-5px) scale(1.02);
            border-color: var(--gem-color);
            box-shadow: 0 0 20px rgba(247, 183, 51, 0.3);
            background: var(--card-bg);
        }
        .selection-card .icon { font-size: 2.5em; margin-bottom: 0; }
        .selection-card .info h4 { font-family: var(--font-main); font-weight: 700; margin: 0 0 5px 0; font-size: 1em; color: var(--text-light);}
        .selection-card .info p { font-size: 0.85em; margin: 0; color: var(--text-medium); line-height: 1.4; max-width: none; }

        #character-preview-panel {
            width: 100%;
            max-width: 400px;
            min-width: 300px;
            background: var(--card-bg);
            border-radius: 15px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #character-preview-display {
            width: 200px;
            height: 200px;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 100px;
            transition: all 0.3s ease;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }
        #character-preview-stats { list-style: none; padding: 0; margin: 20px 0 0 0; text-align: left; }
        #character-preview-stats li { background: var(--bg-light); padding: 10px 15px; margin-bottom: 8px; border-radius: 8px; font-weight: 600; }
        #character-preview-stats .stat-modifier {
            color: var(--gem-color);
            font-size: 0.9em;
            margin-left: 8px;
            font-weight: 700;
        }

        #abilities-panel {
            padding-top: 1.5rem;
        }
        .ability-info-card {
            background: var(--bg-light);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 8px;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .ability-info-card .icon {
            font-size: 2em;
        }
        .ability-info-card .info {
             flex: 1;
        }
        .ability-info-card h4 {
            margin: 0 0 4px 0;
            color: var(--gem-color);
            font-size: 1em;
            font-weight: 700;
        }
        .ability-info-card p {
            margin: 0;
            font-size: 0.85em;
            color: var(--text-medium);
            line-height: 1.4;
        }

        /* --- Loadout Footer --- */
        #loadout-footer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            width: calc(100% - 40px);
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
        }
        #loadout-footer > * {
            pointer-events: all;
        }

        #team-composition-display {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 15px;
            border-top: 2px solid var(--gem-color);
            display: flex;
            gap: 15px;
            justify-content: flex-start;
            flex-wrap: wrap;
        }
        .teammate-card { display: flex; flex-direction: column; align-items: center; background: var(--bg-light); padding: 10px; border-radius: 10px; width: 110px; }
        .teammate-card .name { font-weight: 700; font-size: 0.9em; }
        .teammate-card .icon { font-size: 2.5em; margin: 5px 0; }
        .teammate-card .archetype-name {
            font-size: 0.8em;
            color: var(--text-medium);
            margin-top: 3px;
            font-weight: 600;
        }

        /* --- In-Game UI --- */
        #game-ui { position: absolute; top: 0; left: 0; right: 0; bottom: 0; color: white; display: none; z-index: 5; padding: clamp(1rem, 2vw, 1.5rem); pointer-events: none; font-family: var(--font-main); }
        .top-bar-center { position: absolute; top: clamp(1rem, 2vw, 1.5rem); left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; background: var(--card-bg); padding: clamp(0.5rem, 1.5vw, 0.75rem) clamp(1.5rem, 4vw, 2rem); border-radius: 18px; border: 1px solid rgba(255,255,255,0.1); pointer-events: all; }
        .score-timer-container { display: flex; align-items: center; gap: 1.5rem; }
        .team-score { font-size: clamp(2em, 4vw, 2.5em); font-family: var(--font-mono); font-weight: 700; transition: transform 0.2s ease-out; }
        .score-flash { animation: score-pulse 0.6s 1; }
        @keyframes score-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); filter: brightness(2); }
            100% { transform: scale(1); }
        }
        #team-a-score { color: var(--team-a-color); }
        #team-b-score { color: var(--team-b-color); }
        #game-timer { font-size: clamp(1.5em, 3vw, 2em); color: var(--text-light); font-family: var(--font-mono); }
        .player-stats { display: flex; gap: 1rem; margin-top: 0.5rem; font-size: clamp(0.8em, 1.8vw, 0.9em); font-weight: 600; color: var(--text-medium); }
        #player-hp { --hp-percent: 100%; position: relative; color: var(--text-light); transition: color 0.2s; z-index: 1; }
        #player-hp::before { content: ''; position: absolute; left: -5px; top: 0; bottom: 0; width: calc(var(--hp-percent) + 10px); background: linear-gradient(90deg, var(--team-a-color), var(--gem-color)); border-radius: 5px; opacity: 0.4; z-index: -1; transition: width 0.3s ease; }
        #player-hp.hurt { animation: flashRed 0.3s; }
        @keyframes flashRed { 50% { color: #fff; filter: brightness(2); } }
        .ability-bar { position: absolute; right: clamp(1rem, 2vw, 1.5rem); top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 1rem; pointer-events: all; }
        .ability-slot {
            width: clamp(55px, 10vmin, 70px);
            height: clamp(55px, 10vmin, 70px);
            background: var(--card-bg); border: 2px solid var(--bg-light); border-radius: 15px; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; overflow: hidden; transition: all 0.2s ease; box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        .ability-slot:not(.on-cooldown) { border-color: var(--gem-color); box-shadow: 0 0 15px var(--gem-color); }
        .ability-icon { font-size: clamp(1.8em, 4vmin, 2.2em); }
        .ability-key { position: absolute; top: 4px; right: 7px; font-family: var(--font-mono); font-size: 0.8em; opacity: 0.8; }
        .cooldown-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); color: white; display: flex; align-items: center; justify-content: center; font-size: clamp(1.2em, 3vmin, 1.6em); font-family: var(--font-mono); transition: opacity 0.2s; opacity: 0; pointer-events: none; }
        .ability-slot.on-cooldown .cooldown-overlay { opacity: 1; }
        #message-box { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); background: var(--card-bg); padding: 15px 30px; border: 2px solid var(--gem-color); border-radius: 12px; font-size: 1.1em; font-family: var(--font-main); font-weight: 600; display: none; z-index: 20; box-shadow: 0 5px 15px rgba(0,0,0,0.3); animation: fadeIn 0.3s; }
        #minimap-container {
            position: absolute;
            top: clamp(1rem, 2vw, 1.5rem);
            right: clamp(1rem, 2vw, 1.5rem);
            width: clamp(150px, 18vw, 250px);
            height: clamp(100px, 18vh, 180px);
            border: 2px solid rgba(255,255,255,0.1); border-radius: 15px; overflow: hidden; pointer-events: all; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #minimapCanvas {
            width: 100%;
            height: 100%;
        }
        .phone-warning {
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(1.5em, 4vw, 2.5em);
            font-family: var(--font-title);
            color: var(--team-a-color);
            text-shadow: 0 0 15px black;
            display: none;
            animation: pulse-glow 1.5s infinite alternate;
            z-index: 10;
        }

        /* --- Respawn Screen --- */
        #respawn-screen {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: linear-gradient(to top, rgba(18, 18, 28, 0.95), transparent);
            padding: 30px; z-index: 6; display: none; flex-direction: column;
            align-items: center; pointer-events: all; overflow: hidden;
        }
        #respawn-screen::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(rgba(18, 18, 28, 0) 50%, rgba(0,0,0,0.25) 50%), linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06));
            background-size: 100% 4px, 3px 100%;
            z-index: -1;
            pointer-events: none;
            animation: scanlines 20s linear infinite;
        }
        @keyframes scanlines { from { background-position: 0 0; } to { background-position: 0 100%; } }
        #respawn-screen h2 { margin: 0 0 5px 0; color: var(--team-a-color); }
        #respawn-screen p { margin: 0 0 20px 0; font-size: 1.2em; font-family: var(--font-mono); }

        /* --- Leaderboard & Game Over Screens --- */
        #leaderboard-screen {
            justify-content: center; align-items: flex-start; padding-top: 5vh;
            background: rgba(18, 18, 28, 0.85);
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
        }
        #leaderboard-container {
            display: flex; gap: 2rem; width: 100%;
            max-width: 1200px; justify-content: center; flex-wrap: wrap;
        }
        .leaderboard-team-panel {
            background: var(--card-bg); border-radius: 15px; padding: 1.5rem;
            flex: 1; min-width: 400px; border-top: 4px solid var(--team-color);
        }
        .leaderboard-team-panel h3 {
            color: var(--team-color); margin: 0 0 1rem 0;
            text-align: left; font-size: 1.6em;
        }
        .leaderboard-table {
            width: 100%; border-collapse: collapse; font-size: 0.9em;
        }
        .leaderboard-table th, .leaderboard-table td {
            padding: 10px 12px; text-align: left;
            border-bottom: 1px solid var(--bg-light);
        }
        .leaderboard-table th {
            font-weight: 700; color: var(--text-medium);
            text-transform: uppercase; font-size: 0.8em; letter-spacing: 1px;
        }
        .leaderboard-table tr:last-child td { border-bottom: none; }
        .leaderboard-table .ally-ability { font-family: var(--font-mono); font-weight: 700; }
        .leaderboard-table .ally-ability .ready { color: #2ecc71; }
        .leaderboard-table .ally-ability .cooldown { color: #f1c40f; }
        .leaderboard-table .status-dead { color: var(--team-a-color); font-weight: 700; }

        #gameover-screen .gameover-card { max-width: 1300px; width: 90%; }
        #final-leaderboard-container { margin-top: 2rem; }
        #winner-announcement { animation: pulse-glow 2s infinite alternate; }
        @keyframes pulse-glow {
            from { text-shadow: 0 0 10px #fff, 0 0 20px var(--gem-color); }
            to { text-shadow: 0 0 20px #fff, 0 0 40px var(--gem-color); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="game-ui">
            <div id="phone-stolen-warning-a" class="phone-warning">OUR PHONE HAS BEEN TAKEN!</div>
            <div id="phone-stolen-warning-b" class="phone-warning">OUR PHONE HAS BEEN TAKEN!</div>

            <div class="top-bar-center">
                <div class="score-timer-container">
                    <div id="team-a-score" class="team-score">0</div>
                    <div id="game-timer">12:00</div>
                    <div id="team-b-score" class="team-score">0</div>
                </div>
                <div class="player-stats">
                    <span id="player-hp">HP: 100</span>
                    <span>|</span>
                    <span id="player-kda">KDA: 0/0/0</span>
                    <span>|</span>
                    <span id="player-rank">1st</span>
                </div>
            </div>
            <div class="ability-bar">
                <div id="ability-1" class="ability-slot">
                    <div class="ability-icon"></div>
                    <div class="ability-key">Q</div>
                    <div class="cooldown-overlay"></div>
                </div>
                <div id="ability-2" class="ability-slot">
                    <div class="ability-icon"></div>
                    <div class="ability-key">E</div>
                    <div class="cooldown-overlay"></div>
                </div>
            </div>
            <div id="minimap-container">
                <canvas id="minimapCanvas"></canvas>
            </div>
        </div>

        <div id="respawn-screen">
             <h2>YOU ARE ELIMINATED</h2>
             <p>Respawning in <span id="respawn-timer">10</span>s</p>
             <div id="respawn-weapon-selection" class="card-container"></div>
        </div>

        <div id="message-box"></div>

        <div id="start-screen" class="screen active">
            <div class="bg-characters">
                <div class="character-silhouette char1">🏃</div>
                <div class="character-silhouette char2">👑</div>
                <div class="character-silhouette char3">💪</div>
                <div class="character-silhouette char4">🤓</div>
                <div class="character-silhouette char5">📱</div>
            </div>
            <div class="ui-card">
                <h1>Precision</h1>
                <p style="margin-top: -10px; margin-bottom: 30px;">Choose your gear and jump into the fray!</p>
                <input type="text" id="player-name-input" placeholder="Enter Your Name" value="Player" maxlength="12">
                <button id="show-lobby-btn">Continue</button>
            </div>
        </div>

        <div id="lobby-screen" class="screen">
            <h2 id="lobby-title">Join a Team</h2>
            <div id="lobby-container">
                <div class="team-panel team-a">
                    <h3 id="team-a-name-header">Team A</h3>
                    <ul class="player-list" id="team-a-list"></ul>
                    <div class="team-actions" id="team-a-actions"></div>
                    <div class="captain-actions" id="team-a-captain-actions" style="display: none;">
                        <p>CAPTAIN PRIVILEGES</p>
                        <input type="text" id="team-a-rename-input" placeholder="Enter new team name" maxlength="12">
                        <button id="rename-team-a-btn">Rename</button>
                    </div>
                </div>
                <div class="team-panel team-b">
                    <h3 id="team-b-name-header">Team B</h3>
                    <ul class="player-list" id="team-b-list"></ul>
                    <div class="team-actions" id="team-b-actions"></div>
                    <div class="captain-actions" id="team-b-captain-actions" style="display: none;">
                        <p>CAPTAIN PRIVILEGES</p>
                        <input type="text" id="team-b-rename-input" placeholder="Enter new team name" maxlength="12">
                        <button id="rename-team-b-btn">Rename</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="loadout-screen" class="screen">
            <h2>Choose Your Loadout</h2>
            <div id="loadout-container">
                <div class="loadout-panel">
                    <h3>Archetype</h3>
                    <div id="archetype-selection-container" class="card-container"></div>
                </div>

                <div id="character-preview-panel">
                    <h3>Your Operator</h3>
                    <div id="character-preview-display">?</div>
                    <ul id="character-preview-stats">
                        </ul>
                </div>

                <div class="loadout-panel">
                    <h3>Weapon</h3>
                    <div id="weapon-selection-container" class="card-container"></div>
                    <div id="abilities-panel" style="display: none;">
                        <h3>Abilities</h3>
                        <div id="abilities-display" class="card-container"></div>
                    </div>
                </div>
            </div>

            <div id="loadout-footer">
                <div id="team-composition-display" style="display: none;">
                    </div>
                <button id="start-game-btn" style="display: none;">Start Match</button>
            </div>
        </div>

        <div id="leaderboard-screen" class="screen">
            <div id="leaderboard-container">
                </div>
        </div>

        <div id="gameover-screen" class="screen">
            <div class="ui-card gameover-card">
                <h1>Game Over</h1>
                <h2 id="winner-announcement"></h2>
                <p id="game-stats"></p>
                <div id="final-leaderboard-container"></div>
                <button id="play-again-btn">Play Again</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const minimapContainer = document.getElementById('minimap-container');
        const respawnScreen = document.getElementById('respawn-screen');
        const respawnTimerEl = document.getElementById('respawn-timer');
        const screens = {
            start: document.getElementById('start-screen'),
            lobby: document.getElementById('lobby-screen'),
            loadout: document.getElementById('loadout-screen'),
            leaderboard: document.getElementById('leaderboard-screen'),
            gameover: document.getElementById('gameover-screen')
        };

        // --- Game State ---
        let gameState = 'START_SCREEN';
        let lobbyState = 'TEAM_JOIN';
        let localPlayer = null, animationFrameId, gameTimerInterval;
        let teamAScore = 0, teamBScore = 0, gameTime = 12 * 60;
        let teamAName = 'Team A', teamBName = 'Team B';
        let allPlayers = [], teamARoster = [], teamBRoster = [], captainA = null, captainB = null;
        let teamAPhoneStolen = false, teamBPhoneStolen = false;

        // --- Game Objects ---
        let gameObjects = [], projectiles = [], phones = [], turrets = [], acidPuddles = [], visualEffects = [], barriers = [];
        let damageNumbers = [], statusTexts = [], particles = [];

        // --- Constants & Config ---
        const scoreToWin = 6;
        const mapWidth = 6000, mapHeight = 4000;
        const camera = { x: 0, y: 0, targetX: 0, targetY: 0 };
        const ENEMY_LINGER_DURATION = 3000; // how long enemies appear on minimap after losing sight
        const TEAM_A_COLOR_HEX = '#f04d5d';
        const TEAM_B_COLOR_HEX = '#00b8d4';

        // --- Game Data ---
        const abilityInfo = {
            'Ruck': { desc: 'Become completely immune to all damage and effects for 5 seconds, but you cannot move.', icon: '🧱'},
            'Charge': { desc: 'Dash forward for a short distance, becoming unstoppable and knocking back enemies.', icon: '💨'},
            'Sprint': { desc: 'Double your movement speed for 5 seconds.', icon: '⚡'},
            'Kick': { desc: 'A powerful close-range kick that deals massive damage, but leaves you vulnerable.', icon: '💥'},
            'Trauma': { desc: 'Stun enemies in a short radius around you, stopping them in their tracks.', icon: '💫'},
            'Destroy': { desc: 'Instantly destroy all enemy deployables (turrets, walls) in a wide radius.', icon: '💣'},
            'Turret': { desc: 'Deploy a stationary turret that automatically fires at nearby enemies.', icon: '⚙️'},
            'Wall': { desc: 'Create an impassable wall at your target location.', icon: '🧱'},
            'Gun': { desc: "For a short duration, your weapon's damage is doubled.", icon: '🔥'},
            'Cocoon': { desc: 'Gain a massive, temporary health boost, but your damage is reduced to 1.', icon: '🐛'},
            'Ping': { desc: 'Reveal the position of all enemies on the map to your entire team for 2 seconds.', icon: '📡'},
            'Glitch': { desc: 'Grant a powerful, permanent buff to an ally that doubles their stats until they are eliminated.', icon: '👾'},
            'Annihilation': { desc: 'Fires a high-speed particle that instantly kills the first enemy it hits.', icon: '🎯'},
            'Ebola': { desc: 'Infects the closest enemy with a deadly plague that deals damage over time until death and spreads to nearby enemies.', icon: '☣️'},
            'Curl': { desc: 'Lifts a nearby enemy and throws them. If they hit a wall, they take 50 damage. Your damage is halved for 15s after use.', icon: '💪'},
            'Rest': { desc: 'Freeze in place for 3 seconds to prepare. Afterwards, all of your stats are doubled for 10 seconds.', icon: '😴'},
            'Awaken': { desc: 'Can only be used when below 50% health. Permanently multiplies all stats by 2.5x until you are eliminated.', icon: '😡'},
            'Help': { desc: 'A swift character with abilities yet to be defined.', icon: '❓'}
        };
        const characterClasses = {
            'Tank': { desc: 'The Tank is a front-line bruiser with immense health and survivability. Ideal for holding objectives and soaking up damage.', icon: '🛡️', base: { health: 200, speed: 4, damage: 8, regen: 1 }, abilities: ['Ruck', 'Charge'] },
            'Athlete': { desc: 'The Athlete is a lightning-fast scout and flanker. Their speed allows them to navigate the map quickly and escape danger.', icon: '🏃', base: { health: 80, speed: 10, damage: 10, regen: 0.4 }, abilities: ['Sprint', 'Kick'] },
            'Bully': { desc: 'The Bully specializes in disrupting enemies and clearing the way for their team. They use brute force to stop opponents in their tracks.', icon: '💪', base: { health: 100, speed: 7, damage: 12, regen: 0.2 }, abilities: ['Trauma', 'Destroy'] },
            'Engineer': { desc: 'The Engineer controls the battlefield by deploying stationary turrets and impenetrable walls. A master of area denial.', icon: '🔧', base: { health: 120, speed: 7, damage: 10, regen: 0.2 }, abilities: ['Turret', 'Wall'] },
            'Nerd': { desc: 'The Nerd is a glass cannon, capable of immense burst damage but vulnerable to sustained fire. A high-risk, high-reward choice.', icon: '🤓', base: { health: 60, speed: 8, damage: 8, regen: 0.4 }, abilities: ['Gun', 'Cocoon'] },
            'CS Student': { desc: 'The CS Student is a support-focused character who reveals enemy positions and grants powerful, permanent buffs to their allies.', icon: '💻', base: { health: 100, speed: 7, damage: 10, regen: 0.2 }, abilities: ['Ping', 'Glitch'] },
            'Science Student': { desc: 'A deadly specialist who can eliminate targets instantly or with persistent, spreading plagues.', icon: '🔬', base: { health: 90, speed: 8, damage: 10, regen: 0.8 }, abilities: ['Annihilation', 'Ebola'] },
            'Gym Hogger': { desc: 'A powerful brawler who manipulates enemy positions and can temporarily become a powerhouse.', icon: '🏋️', base: { health: 120, speed: 10, damage: 14, regen: 1.4 }, abilities: ['Curl', 'Rest'] },
            'Quiet Kid': { desc: 'A dangerous threat who becomes exponentially more powerful when pushed to their limit.', icon: '🤫', base: { health: 100, speed: 10, damage: 12, regen: 0.8 }, abilities: ['Awaken', 'Help'] },
            'Teacher\'s Pet': { desc: 'A swift character with abilities yet to be defined.', icon: '🍎', base: { health: 60, speed: 12, damage: 6, regen: 0.4 }, abilities: ['Help', 'Help'] }
        };
        const weaponArchetypes = {
            'Acid Beaker': { desc: 'A long-range weapon that applies a corrosive damage-over-time effect to enemies.', icon: '🧪', damageMultiplier: 0.9, fireRateMultiplier: 0.8 },
            'Nail Gun': { desc: 'A high-speed, close-range weapon that shreds enemies with a rapid succession of nails.', icon: '🔫', damageMultiplier: 1.2, fireRateMultiplier: 1.4 },
            'Metal Bottle': { desc: 'A reliable, standard-issue weapon with a solid balance of damage and accuracy.', icon: '🍾', damageMultiplier: 1.1, fireRateMultiplier: 0.8 },
            'Tennis Ball': { desc: 'An extremely fast-firing weapon that peppers enemies with low-damage projectiles.', icon: '🎾', damageMultiplier: 0.7, fireRateMultiplier: 1.6 },
            'Scissor': { desc: 'A slow but devastating weapon that inflicts a grievous wound, preventing healing.', icon: '✂️', damageMultiplier: 1.5, fireRateMultiplier: 0.5 }
        };
        const abilityCooldowns = {
            'Ruck': 60, 'Charge': 60, 'Sprint': 45, 'Kick': 30, 'Trauma': 60, 'Destroy': 30,
            'Turret': 30, 'Wall': 45, 'Gun': 60, 'Cocoon': 45, 'Ping': 60, 'Glitch': 120,
            'Annihilation': 60, 'Ebola': 90, 'Curl': 30, 'Rest': 45, 'Awaken': 120, 'Help': 1
        };

        // --- Player Input State ---
        const keys = { w: false, a: false, s: false, d: false };
        let mousePos = { x: 0, y: 0 };
        let isMouseDown = false;
        let lastShootTime = 0;
        let playerChoices = { name: "Player", archetype: null, weapon: null };

        // --- Event Listeners ---
        function setupEventListeners() {
            document.getElementById('show-lobby-btn').addEventListener('click', enterLobby);
            document.getElementById('start-game-btn').addEventListener('click', startGame);
            document.getElementById('play-again-btn').addEventListener('click', () => window.location.reload());
            document.getElementById('rename-team-a-btn').addEventListener('click', () => renameTeam('A'));
            document.getElementById('rename-team-b-btn').addEventListener('click', () => renameTeam('B'));

            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (key in keys) keys[key] = true;
                if (gameState === 'gameplay') {
                    if (key === 'q') activateAbility(localPlayer, 0);
                    if (key === 'e') activateAbility(localPlayer, 1);
                    if (key === 'tab') {
                        e.preventDefault();
                        updateLeaderboard();
                        screens.leaderboard.classList.add('active');
                    }
                }
            });
            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (key in keys) keys[key] = false;
                if (gameState === 'gameplay' && key === 'tab') {
                    screens.leaderboard.classList.remove('active');
                }
            });
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            });
            canvas.addEventListener('mousedown', () => { isMouseDown = true; });
            canvas.addEventListener('mouseup', () => { isMouseDown = false; });
            canvas.addEventListener('mouseleave', () => { isMouseDown = false; });
        }


        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            minimapCanvas.width = minimapContainer.clientWidth;
            minimapCanvas.height = minimapContainer.clientHeight;
        }

        function showScreen(screenName) {
            Object.values(screens).forEach(s => s.classList.remove('active'));
            if (screens[screenName]) screens[screenName].classList.add('active');

            const isGameVisible = screenName === 'none';
            document.getElementById('game-ui').style.display = isGameVisible ? 'block' : 'none';
            if (isGameVisible) {
                resizeCanvas();
            }
        }

        function showMessage(text, duration = 3000) {
            const el = document.getElementById('message-box');
            el.textContent = text; el.style.display = 'block';
            setTimeout(() => { el.style.display = 'none'; }, duration);
        }

        // --- Lobby and Loadout Logic ---
        function enterLobby() {
            playerChoices.name = document.getElementById('player-name-input').value.trim() || "Player";
            localPlayer = { name: playerChoices.name, isBot: false, team: null, votes: 0, hasVoted: false };
            const botNames = ["Shadow", "Vortex", "Blaze", "Fury", "Reaper", "Ghost", "Spike", "Viper", "Rogue"];
            allPlayers = [localPlayer, ...botNames.map(name => ({ name, isBot: true, team: null, votes: 0, hasVoted: false }))];
            teamARoster = []; teamBRoster = []; captainA = null; captainB = null;
            teamAName = 'Team A'; teamBName = 'Team B';
            lobbyState = 'TEAM_JOIN';
            document.getElementById('lobby-title').textContent = 'Join a Team';
            showScreen('lobby');
            updateLobbyUI();
        }

        function joinTeam(team) {
            if (localPlayer.team) return;
            localPlayer.team = team;
            if (team === 'A') teamARoster.push(localPlayer); else teamBRoster.push(localPlayer);

            let unassignedBots = allPlayers.filter(p => p.isBot);
            unassignedBots.forEach(bot => {
                 if (teamARoster.length <= teamBRoster.length) { teamARoster.push(bot); bot.team = 'A'; }
                 else { teamBRoster.push(bot); bot.team = 'B'; }
            });

            lobbyState = 'CAPTAIN_VOTE';
            document.getElementById('lobby-title').textContent = 'Vote for Your Captain';
            updateLobbyUI();
        }

        function handleVote(votedForPlayerName) {
            if (lobbyState !== 'CAPTAIN_VOTE' || localPlayer.hasVoted) return;

            const roster = localPlayer.team === 'A' ? teamARoster : teamBRoster;
            const votedForPlayer = roster.find(p => p.name === votedForPlayerName);
            if (!votedForPlayer) return;

            localPlayer.hasVoted = true;
            votedForPlayer.votes++;

            // Simulate bot votes once
            roster.filter(p => p.isBot).forEach(bot => {
                if (!bot.hasVoted) {
                    roster[Math.floor(Math.random() * roster.length)].votes++;
                    bot.hasVoted = true;
                }
            });
            // Simulate enemy bot votes
            const aiRoster = localPlayer.team === 'A' ? teamBRoster : teamARoster;
            aiRoster.forEach(bot => {
                if (!bot.hasVoted) {
                    aiRoster[Math.floor(Math.random() * aiRoster.length)].votes++;
                    bot.hasVoted = true;
                }
            });


            // Determine captains based on votes
            const determineCaptain = (roster) => roster.sort((a,b) => b.votes - a.votes)[0];
            captainA = determineCaptain(teamARoster);
            captainB = determineCaptain(teamBRoster);

            updateLobbyUI();

            if (captainA && captainB) {
                lobbyState = 'CLASS_SELECT';
                setTimeout(enterLoadoutSelection, 1000);
            }
        }

        function enterLoadoutSelection() {
            showScreen('loadout');
            setupClassSelection();
            updateCharacterPreview();
        }

        function setupClassSelection() {
            const archetypeContainer = document.getElementById('archetype-selection-container');
            const weaponContainer = document.getElementById('weapon-selection-container');
            archetypeContainer.innerHTML = ''; // Clear previous
            weaponContainer.innerHTML = '';

            for(const className in characterClasses) {
                const safeName = className.replace(/\s+/g, '');
                const classData = characterClasses[className];
                const card = document.createElement('div');
                card.className = 'selection-card';
                card.id = `archetype-${safeName}`;
                card.innerHTML = `<div class="icon">${classData.icon}</div><div class="info"><h4>${className}</h4><p>${classData.desc}</p></div>`;
                card.onclick = () => selectArchetype(className);
                archetypeContainer.appendChild(card);
            }

            for (const name in weaponArchetypes) {
                const data = weaponArchetypes[name];
                const card = document.createElement('div');
                card.className = 'selection-card';
                card.id = `weapon-${name.replace(/\s+/g, '')}`;
                card.innerHTML = `<div class="icon">${data.icon}</div><div class="info"><h4>${name}</h4><p>${data.desc}</p></div>`;
                card.onclick = () => selectWeapon(name);
                weaponContainer.appendChild(card);
            }
        }

        function selectArchetype(name) {
            if (lobbyState !== 'CLASS_SELECT' && lobbyState !== 'READY') return;
            playerChoices.archetype = name;
            document.querySelectorAll('#archetype-selection-container .selection-card').forEach(c => c.classList.remove('selected'));
            document.getElementById(`archetype-${name.replace(/\s+/g, '')}`).classList.add('selected');
            updateCharacterPreview();
            checkSelections();
        }

        function selectWeapon(name) {
            if (lobbyState !== 'CLASS_SELECT' && lobbyState !== 'READY') return;
            playerChoices.weapon = name;
            document.querySelectorAll('#weapon-selection-container .selection-card').forEach(c => c.classList.remove('selected'));
            document.getElementById(`weapon-${name.replace(/\s+/g, '')}`).classList.add('selected');
            updateCharacterPreview();
            checkSelections();
        }

        function checkSelections() {
             if (playerChoices.archetype && playerChoices.weapon) {
                lobbyState = 'READY';
                document.getElementById('start-game-btn').style.display = 'block';
                document.getElementById('team-composition-display').style.display = 'flex';
                const classNames = Object.keys(characterClasses);
                const weaponNames = Object.keys(weaponArchetypes);

                // Assign class and weapon to player object and bots
                localPlayer.class = playerChoices.archetype;
                localPlayer.weapon = playerChoices.weapon;

                allPlayers.filter(p => p.isBot && !p.class).forEach(bot => {
                    bot.class = classNames[Math.floor(Math.random() * classNames.length)];
                    bot.weapon = weaponNames[Math.floor(Math.random() * weaponNames.length)];
                });
                updateTeamComposition();
            }
        }

        function renameTeam(team) {
            if (team === 'A' && localPlayer === captainA) {
                const newName = document.getElementById('team-a-rename-input').value.trim();
                if (newName) teamAName = newName;
            } else if (team === 'B' && localPlayer === captainB) {
                const newName = document.getElementById('team-b-rename-input').value.trim();
                if (newName) teamBName = newName;
            }
            updateLobbyUI();
        }

        function updateLobbyUI() {
            document.getElementById('team-a-name-header').textContent = teamAName;
            document.getElementById('team-b-name-header').textContent = teamBName;

            const listA = document.getElementById('team-a-list'), listB = document.getElementById('team-b-list');
            const generatePlayerHTML = (p, team) => {
                const isCaptain = p === (team === 'A' ? captainA : captainB);
                const isLocal = p === localPlayer;
                const name = `${p.name} ${isCaptain ? '👑' : ''}`;
                const classes = `${isLocal ? 'local-player' : ''} ${lobbyState === 'CAPTAIN_VOTE' && localPlayer.team === team && !localPlayer.hasVoted ? 'can-vote' : ''}`;
                const clickHandler = (classes.includes('can-vote')) ? `onclick="handleVote('${p.name}')"` : '';
                return `<li class="${classes}" ${clickHandler}>${name}</li>`;
            };

            listA.innerHTML = teamARoster.map(p => generatePlayerHTML(p, 'A')).join('');
            listB.innerHTML = teamBRoster.map(p => generatePlayerHTML(p, 'B')).join('');

            const actionsA = document.getElementById('team-a-actions'), actionsB = document.getElementById('team-b-actions');
            actionsA.innerHTML = ''; actionsB.innerHTML = '';
            if(lobbyState === 'TEAM_JOIN') {
                actionsA.innerHTML = '<button onclick="joinTeam(\'A\')">Join Team A</button>';
                actionsB.innerHTML = '<button onclick="joinTeam(\'B\')">Join Team B</button>';
            } else {
                 actionsA.innerHTML = `<p>Captain: ${captainA ? captainA.name : 'Voting...'} ${captainA ? '👑' : ''}</p>`;
                 actionsB.innerHTML = `<p>Captain: ${captainB ? captainB.name : 'Voting...'} ${captainB ? '👑' : ''}</p>`;
            }

            document.getElementById('team-a-captain-actions').style.display = (localPlayer === captainA && lobbyState !== 'TEAM_JOIN') ? 'block' : 'none';
            document.getElementById('team-b-captain-actions').style.display = (localPlayer === captainB && lobbyState !== 'TEAM_JOIN') ? 'block' : 'none';
        }

        function updateCharacterPreview() {
            const preview = document.getElementById('character-preview-display');
            const statsList = document.getElementById('character-preview-stats');
            const abilitiesPanel = document.getElementById('abilities-panel');
            const abilitiesDisplay = document.getElementById('abilities-display');

            if (localPlayer.team === 'A') {
                preview.style.backgroundColor = 'var(--team-a-color)';
                preview.style.borderRadius = '50%';
            } else if (localPlayer.team === 'B') {
                preview.style.backgroundColor = 'var(--team-b-color)';
                preview.style.borderRadius = '10px';
            }

            statsList.innerHTML = `<li>HP: --</li><li>Speed: --</li><li>Damage: --</li><li>Fire Rate: --</li>`;
            abilitiesDisplay.innerHTML = '';
            abilitiesPanel.style.display = 'none';
            preview.textContent = '?';

            if (playerChoices.archetype) {
                const classData = characterClasses[playerChoices.archetype];
                const baseStats = classData.base;
                preview.textContent = classData.icon;

                let finalDamage = baseStats.damage;
                let finalFireRate = 1.0;
                let damageModifierText = '';
                let fireRateModifierText = '';

                if (playerChoices.weapon) {
                    const weaponData = weaponArchetypes[playerChoices.weapon];
                    finalDamage *= weaponData.damageMultiplier;
                    finalFireRate *= weaponData.fireRateMultiplier;
                    damageModifierText = `<span class="stat-modifier">(${weaponData.damageMultiplier}x)</span>`;
                    fireRateModifierText = `<span class="stat-modifier">(${weaponData.fireRateMultiplier}x)</span>`;
                }

                statsList.innerHTML = `
                    <li>HP: ${baseStats.health}</li>
                    <li>Speed: ${baseStats.speed}</li>
                    <li>Damage: ${finalDamage.toFixed(1)} ${damageModifierText}</li>
                    <li>Fire Rate: ${finalFireRate.toFixed(1)}/s ${fireRateModifierText}</li>
                `;

                abilitiesPanel.style.display = 'block';
                let abilitiesHTML = '';

                classData.abilities.forEach(abilityName => {
                    const info = abilityInfo[abilityName] || {desc: 'No description.', icon: '❓'};
                    abilitiesHTML += `
                        <div class="ability-info-card">
                             <div class="icon">${info.icon}</div>
                             <div class="info">
                                <h4>${abilityName}</h4>
                                <p>${info.desc}</p>
                            </div>
                        </div>
                    `;
                });
                abilitiesDisplay.innerHTML = abilitiesHTML;
            }
        }

        function updateTeamComposition() {
            const container = document.getElementById('team-composition-display');
            let html = '<h3>Your Squad</h3>';
            const roster = localPlayer.team === 'A' ? teamARoster : teamBRoster;

            roster.forEach(p => {
                if (p === localPlayer) return;
                const classIcon = p.class ? characterClasses[p.class].icon : '?';
                const weaponIcon = p.weapon ? weaponArchetypes[p.weapon].icon : '?';
                const className = p.class || 'Selecting...';
                html += `
                    <div class="teammate-card">
                        <div class="name">${p.name}</div>
                        <div class="icon">${classIcon} ${weaponIcon}</div>
                        <div class="archetype-name">${className}</div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function setupRespawnScreen() {
            const container = document.getElementById('respawn-weapon-selection');
            container.innerHTML = '';
            for (const name in weaponArchetypes) {
                const data = weaponArchetypes[name];
                const card = document.createElement('div');
                card.className = 'selection-card';
                card.id = `respawn-weapon-${name.replace(/\s+/g, '')}`;
                card.innerHTML = `<div class="icon">${data.icon}</div><div class="info"><h4>${name}</h4><p>${data.desc}</p></div>`;
                card.onclick = () => selectNextWeapon(name);
                container.appendChild(card);
            }
        }

        function selectNextWeapon(weaponName) {
            if (!localPlayer || localPlayer.isAlive) return;
            localPlayer.nextWeapon = weaponName;
            document.querySelectorAll('#respawn-weapon-selection .selection-card').forEach(c => c.classList.remove('selected'));
            document.getElementById(`respawn-weapon-${weaponName.replace(/\s+/g, '')}`).classList.add('selected');
        }

        function applyWeaponStats(player) {
            const classInfo = characterClasses[player.class];
            const weaponInfo = weaponArchetypes[player.weapon];
            if (!classInfo || !weaponInfo) return;

            let baseDamage = player.isCaptain ? classInfo.base.damage + 2 : classInfo.base.damage;
            let damageMultiplier = weaponInfo.damageMultiplier;

            // Apply ability effects
            if (player.effects.gun) damageMultiplier *= 2;
            if (player.effects.damageDown) damageMultiplier *= 0.5;
            if (player.effects.pumped) damageMultiplier *= 2;
            if (player.effects.awakened) damageMultiplier *= 2.5;
            if (player.effects.glitched) baseDamage *= 2; // Glitch affects base damage before multipliers
            if (player.effects.cocoon) baseDamage = 1; // Cocoon overrides everything to 1 damage

            player.damage = baseDamage * damageMultiplier;
            player.fireRate = 1 * weaponInfo.fireRateMultiplier;
            player.baseRegen = classInfo.base.regen;

            let finalRegen = player.baseRegen;
            if (player.effects.regenBlock) finalRegen = 0;
            if (player.effects.pumped) finalRegen *= 2;
            if (player.effects.awakened) finalRegen *= 2.5;
            player.regen = finalRegen;

            let finalSpeed = player.baseSpeed;
            if (player.effects.sprint) finalSpeed *= 2;
            if (player.effects.pumped) finalSpeed *= 2;
            if (player.effects.awakened) finalSpeed *= 2.5;
            player.speed = finalSpeed;
        }

        // --- Game Core Logic ---
        function startGame() {
            setupLocalGame();
            gameState = 'gameplay';
            showScreen('none');
            gameTimerInterval = setInterval(updateTimer, 1000);
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function setupLocalGame() {
            gameObjects = [], projectiles = [], turrets = [], phones = [], acidPuddles = [], visualEffects = [], barriers = [];
            damageNumbers = [], statusTexts = [], particles = [];
            teamAScore = 0; teamBScore = 0;
            teamAPhoneStolen = false; teamBPhoneStolen = false;
            gameTime = 12 * 60;

            const allAssignedPlayers = [...teamARoster, ...teamBRoster];
            allAssignedPlayers.forEach(p => {
                const isCaptain = p === captainA || p === captainB;
                gameObjects.push(createPlayer(p, isCaptain));
            });

            localPlayer = gameObjects.find(p => !p.isBot);
            if(localPlayer) localPlayer.nextWeapon = localPlayer.weapon;

            camera.x = localPlayer.x - canvas.width / 2;
            camera.y = localPlayer.y - canvas.height / 2;

            phones = [
                { id: 'A', team: 'A', x: 200, y: mapHeight / 2, baseX: 200, baseY: mapHeight / 2, size: 30, carrier: null, droppedAt: 0 },
                { id: 'B', team: 'B', x: mapWidth - 200, y: mapHeight / 2, baseX: mapWidth - 200, baseY: mapHeight / 2, size: 30, carrier: null, droppedAt: 0 }
            ];
            updateAbilityUI();
            setupRespawnScreen();
        }

        function createPlayer(playerData, isCaptain) {
            const classInfo = characterClasses[playerData.class];
            let stats = { ...classInfo.base };

            const p = {
                id: Math.random(), name: playerData.name, class: playerData.class, team: playerData.team, weapon: playerData.weapon,
                isCaptain, isBot: playerData.isBot, isAlive: true, respawnTimer: 0,
                x: playerData.team === 'A' ? 50 + Math.random() * 250 : mapWidth - 300 + Math.random() * 250,
                y: 100 + Math.random() * (mapHeight - 200),
                radius: 15, maxHealth: stats.health, health: stats.health,
                shield: 0, maxShield: 50,
                speed: stats.speed, baseSpeed: stats.speed, regen: stats.regen, baseRegen: stats.regen,
                kills: 0, deaths: 0, assists: 0, lastShotTime: 0,
                phonesScored: 0,
                phonesStolen: 0,
                ability1Cooldown: 0, ability2Cooldown: 0,
                effects: {},
                isCurrentlyVisible: false,
                lastSeenPosition: null,
                aiState: 'IDLE', aiTarget: null, aiMoveTo: null,
            };
            if (isCaptain) p.maxHealth += 20; p.health = p.maxHealth;
            applyWeaponStats(p);
            return p;
        }

        function createDamageNumber(x, y, amount, color = 'white') {
            damageNumbers.push({ x, y, text: Math.round(amount), color, alpha: 1, startTime: performance.now() });
        }

        function createStatusText(target, text, color = 'white', duration = 1500) {
            statusTexts.push({ targetId: target.id, text, color, endTime: performance.now() + duration });
        }

        function handleShoot() {
            if (gameState !== 'gameplay' || !localPlayer || !localPlayer.isAlive) return;
            const currentTime = performance.now();
            if (currentTime - lastShootTime < (1000 / localPlayer.fireRate )) return;
            lastShootTime = currentTime;
            createProjectile(localPlayer, {x: mousePos.x + camera.x, y: mousePos.y + camera.y});
        }

        function createProjectile(owner, target, specialType = null) {
            const angle = Math.atan2(target.y - owner.y, target.x - owner.x);
            let speed = 12;
            let radius = 5;
            let specialProps = {};
            if (specialType === 'annihilation') {
                speed = 40;
                radius = 8;
                specialProps.isAnnihilation = true;
            }

            projectiles.push({
                x: owner.x, y: owner.y, radius: radius,
                velocity: { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed },
                ownerId: owner.id, team: owner.team, damage: owner.damage, createdAt: Date.now(),
                isAcid: owner.weapon === 'Acid Beaker',
                isScissor: owner.weapon === 'Scissor',
                ...specialProps
            });
        }

        function updateVisibility() {
            if (!localPlayer) return;
            const now = performance.now();
            gameObjects.forEach(p => {
                if (p.team === localPlayer.team || !p.isAlive) return;
                const isVisible = (p.x > camera.x && p.x < camera.x + canvas.width && p.y > camera.y && p.y < camera.y + canvas.height);
                if (isVisible) {
                    p.isCurrentlyVisible = true;
                    p.lastSeenPosition = { x: p.x, y: p.y, timestamp: now };
                } else {
                    p.isCurrentlyVisible = false;
                }
            });
        }

        function gameLoop(timestamp) {
            if (gameState !== 'gameplay') return;
            if (isMouseDown && localPlayer && localPlayer.isAlive) handleShoot();

            updateVisibility();
            updatePlayers(timestamp);
            updateBots(timestamp);
            updateProjectiles();
            updatePhones();
            updateTurrets(timestamp);
            updateBarriers(timestamp);
            updateAcidPuddles(timestamp);
            updateEffects(timestamp);
            handleCollisions();
            draw();
            updateGameUI();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function updatePlayers(timestamp) {
            gameObjects.forEach(p => {
                if (p.isAlive && p.health < p.maxHealth && !p.effects.kickVulnerability) {
                    p.health = Math.min(p.maxHealth, p.health + p.regen / 60);
                }
                if (!p.isAlive && timestamp > p.respawnTimer) {
                    // Revert stats on respawn
                    if (p.effects.glitched) {
                        p.maxHealth /= 2;
                    }
                    if (p.effects.awakened) {
                        p.maxHealth /= 2.5;
                    }

                    p.isAlive = true;
                    p.health = p.maxHealth;
                    p.shield = 0;
                    p.x = p.team === 'A' ? 50 + Math.random() * 250 : mapWidth - 300 + Math.random() * 250;
                    p.y = 100 + Math.random() * (mapHeight - 200);
                    p.effects = {}; // Clear all effects on respawn

                    if (p === localPlayer) {
                        respawnScreen.style.display = 'none';
                        if (p.weapon !== p.nextWeapon) {
                           p.weapon = p.nextWeapon;
                        }
                    }
                    applyWeaponStats(p);
                }
            });

            if (localPlayer && localPlayer.isAlive) {
                let currentSpeed = localPlayer.speed;
                if (localPlayer.effects.rucking || localPlayer.effects.traumatized || localPlayer.effects.charging || localPlayer.effects.resting || localPlayer.effects.isAirborne) currentSpeed = 0;
                if (localPlayer.effects.acidSlow) currentSpeed *= 0.5;

                let dx = 0, dy = 0;
                if (keys.w) dy -= 1;
                if (keys.s) dy += 1;
                if (keys.a) dx -= 1;
                if (keys.d) dx += 1;

                if (dx !== 0 || dy !== 0) {
                    const mag = Math.sqrt(dx*dx + dy*dy);
                    const moveX = (dx / mag) * currentSpeed;
                    const moveY = (dy / mag) * currentSpeed;
                    localPlayer.x += moveX;
                    localPlayer.y += moveY;

                    for (const wall of barriers) {
                        if (Math.hypot(localPlayer.x - wall.x, localPlayer.y - wall.y) < localPlayer.radius + wall.width / 2) {
                            localPlayer.x -= moveX; localPlayer.y -= moveY;
                            break;
                        }
                    }

                    localPlayer.x = Math.max(localPlayer.radius, Math.min(mapWidth - localPlayer.radius, localPlayer.x));
                    localPlayer.y = Math.max(localPlayer.radius, Math.min(mapHeight - localPlayer.radius, localPlayer.y));
                }
            }
        }

        function updateBots(timestamp) {
            gameObjects.filter(p => p.isBot && p.isAlive).forEach(bot => {
                const enemies = gameObjects.filter(e => e.isAlive && e.team !== bot.team);
                const visibleEnemies = enemies.filter(e => {
                    const distance = Math.hypot(e.x - bot.x, e.y - bot.y);
                    return distance < 400 || e.effects.pinged;
                });

                const closestEnemy = visibleEnemies.sort((a, b) => Math.hypot(a.x - bot.x, a.y - bot.y) - Math.hypot(b.x - bot.x, b.y - bot.y))[0];
                const distanceToEnemy = closestEnemy ? Math.hypot(closestEnemy.x - bot.x, closestEnemy.y - bot.y) : Infinity;

                const enemyPhone = phones.find(g => g.team !== bot.team);
                const ownPhone = phones.find(g => g.team === bot.team);
                const carriedPhone = phones.find(g => g.carrier === bot);

                if (carriedPhone) {
                    bot.aiState = 'RETURN_PHONE';
                    bot.aiMoveTo = { x: ownPhone.baseX, y: ownPhone.baseY };
                } else if (distanceToEnemy < 600) {
                    bot.aiState = 'ATTACK';
                    bot.aiTarget = closestEnemy;
                    bot.aiMoveTo = { x: closestEnemy.x, y: closestEnemy.y };
                } else {
                    bot.aiState = 'GET_PHONE';
                    bot.aiMoveTo = { x: enemyPhone.x, y: enemyPhone.y };
                }

                if (bot.aiMoveTo) {
                    let currentSpeed = bot.speed;
                    if (bot.effects.rucking || bot.effects.traumatized || bot.effects.charging || bot.effects.resting || bot.effects.isAirborne) currentSpeed = 0;

                    const angle = Math.atan2(bot.aiMoveTo.y - bot.y, bot.aiMoveTo.x - bot.x);
                    const moveX = Math.cos(angle) * currentSpeed;
                    const moveY = Math.sin(angle) * currentSpeed;
                    bot.x += moveX;
                    bot.y += moveY;

                    for (const wall of barriers) {
                        if (Math.hypot(bot.x - wall.x, bot.y - wall.y) < bot.radius + wall.width / 2) {
                            bot.x -= moveX; bot.y -= moveY;
                            break;
                        }
                    }
                }

                if (bot.aiState === 'ATTACK' && distanceToEnemy < 550) {
                    const currentTime = performance.now();
                     if (currentTime - bot.lastShotTime > (1000 / bot.fireRate )) {
                        createProjectile(bot, bot.aiTarget);
                        bot.lastShotTime = currentTime;
                     }
                }
            });
        }

        function updateTurrets(timestamp) {
            for (let i = turrets.length - 1; i >= 0; i--) {
                const turret = turrets[i];
                if (turret.health <= 0) { turrets.splice(i, 1); continue; }
                if (timestamp > turret.lastShotTime + (1000 / turret.fireRate)) {
                    let closestEnemy = null;
                    let minDistance = 250;
                    gameObjects.forEach(enemy => {
                         if (enemy.isAlive && enemy.team !== turret.team) {
                            const dist = Math.hypot(turret.x - enemy.x, turret.y - enemy.y);
                            if (dist < minDistance) {
                                minDistance = dist;
                                closestEnemy = enemy;
                            }
                        }
                    });
                    if (closestEnemy) {
                        turret.target = closestEnemy;
                        createProjectile(turret, closestEnemy);
                        turret.lastShotTime = timestamp;
                    } else {
                        turret.target = null;
                    }
                }
            }
        }

        function updateBarriers(timestamp) {
            for (let i = barriers.length - 1; i >= 0; i--) {
                const wall = barriers[i];
                if (wall.health <= 0) {
                    barriers.splice(i, 1);
                }
            }
        }

        function updatePhones() {
            const currentTime = Date.now();
            phones.forEach(phone => {
                if (phone.carrier) {
                    if (phone.team === 'A') teamAPhoneStolen = true;
                    if (phone.team === 'B') teamBPhoneStolen = true;
                }
                if (!phone.carrier && (phone.x === phone.baseX && phone.y === phone.baseY)) {
                     if (phone.team === 'A') teamAPhoneStolen = false;
                     if (phone.team === 'B') teamBPhoneStolen = false;
                }

                if (phone.carrier) {
                    phone.x = phone.carrier.x;
                    phone.y = phone.carrier.y - phone.carrier.radius - 15;
                } else if (phone.droppedAt > 0 && currentTime - phone.droppedAt > 60000) {
                    phone.x = phone.baseX; phone.y = phone.baseY; phone.droppedAt = 0;
                    showMessage(`Team ${phone.team}'s phone returned to base!`);
                    if (phone.team === 'A') teamAPhoneStolen = false;
                    if (phone.team === 'B') teamBPhoneStolen = false;
                }
            });
        }

        function updateAcidPuddles(timestamp) {
            let slowedPlayers = new Set();
            for(let i = acidPuddles.length - 1; i >= 0; i--) {
                const puddle = acidPuddles[i];
                if (timestamp > puddle.endTime) { acidPuddles.splice(i, 1); continue; }
                gameObjects.forEach(p => {
                    if (p.isAlive && Math.hypot(p.x - puddle.x, p.y - puddle.y) < p.radius + puddle.radius) {
                        if (p.shield > 0) p.shield = Math.max(0, p.shield - 5 / 60);
                        else p.health = Math.max(0, p.health - 5 / 60);

                        if (!p.effects.acidSlow) {
                           createStatusText(p, "Slowed!", '#2ecc71', 2000);
                        }
                        p.effects.acidSlow = true;
                        slowedPlayers.add(p.id);
                    }
                });
            }
            gameObjects.forEach(p => {
                if (!slowedPlayers.has(p.id)) {
                    delete p.effects.acidSlow;
                }
            });
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.velocity.x; p.y += p.velocity.y;
                if (p.isAcid) {
                    for (let k = 0; k < 2; k++) {
                        particles.push({
                            x: p.x, y: p.y, size: Math.random() * 3 + 1, alpha: 1,
                            color: '#7FFF00', vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                            lifespan: 30
                        });
                    }
                }
                if (p.x < 0 || p.x > mapWidth || p.y < 0 || p.y > mapHeight || Date.now() - p.createdAt > 5000) {
                    projectiles.splice(i, 1);
                }
            }
        }

        function updateEffects(timestamp) {
             gameObjects.forEach(p => {
                if (p.effects.acidDoT && timestamp > (p.effects.acidDoT.lastTick || 0) + 1000) {
                    let dot_damage = 1;
                    if(p.shield > 0) p.shield = Math.max(0, p.shield - dot_damage);
                    else p.health = Math.max(0, p.health - dot_damage);
                    createDamageNumber(p.x, p.y, dot_damage, '#7FFF00');
                    p.effects.acidDoT.lastTick = timestamp;
                    p.effects.hitFlash = { end: timestamp + 100 };
                }

                if (p.effects.ebola && timestamp > (p.effects.ebola.lastTick || 0) + 100) {
                    p.health = Math.max(0, p.health - 1); // 10 DPS
                    createDamageNumber(p.x, p.y, 1, '#2e8b57');
                    p.effects.ebola.lastTick = timestamp;
                    // Spread logic
                    gameObjects.forEach(other => {
                        if (other !== p && other.isAlive && other.team === p.team && !other.effects.ebola) {
                            if (Math.hypot(p.x - other.x, p.y - other.y) < 100) {
                                other.effects.ebola = { lastTick: 0 };
                                createStatusText(other, "INFECTED", "#2e8b57", 2000);
                            }
                        }
                    });
                }

                if (p.effects.charging) {
                    const angle = p.effects.charging.angle;
                    p.x += Math.cos(angle) * 25;
                    p.y += Math.sin(angle) * 25;
                    p.x = Math.max(p.radius, Math.min(mapWidth - p.radius, p.x));
                    p.y = Math.max(p.radius, Math.min(mapHeight - p.radius, p.y));

                    gameObjects.forEach(enemy => {
                        if (enemy !== p && enemy.isAlive && enemy.team !== p.team) {
                            if (Math.hypot(p.x - enemy.x, p.y - enemy.y) < p.radius + enemy.radius) {
                                if (!enemy.effects.knockback) {
                                    const knockbackAngle = Math.atan2(enemy.y - p.y, enemy.x - p.x);
                                    enemy.effects.knockback = { end: timestamp + 300, angle: knockbackAngle, speed: 15 };
                                }
                            }
                        }
                    });
                }

                if (p.effects.isAirborne) {
                    p.x += Math.cos(p.effects.isAirborne.angle) * p.effects.isAirborne.speed;
                    p.y += Math.sin(p.effects.isAirborne.angle) * p.effects.isAirborne.speed;
                    // Check for wall collision
                    if (p.x <= 0 || p.x >= mapWidth || p.y <= 0 || p.y >= mapHeight) {
                        p.health = Math.max(0, p.health - 50);
                        createDamageNumber(p.x, p.y, 50, 'red');
                        delete p.effects.isAirborne;
                    }
                }

                if (p.effects.knockback) {
                    p.x += Math.cos(p.effects.knockback.angle) * p.effects.knockback.speed;
                    p.y += Math.sin(p.effects.knockback.angle) * p.effects.knockback.speed;
                    p.effects.knockback.speed *= 0.9;
                }

                for (const effectName in p.effects) {
                    const effect = p.effects[effectName];
                    if (effect && effect.duration && timestamp > effect.end) {
                        if (effectName === 'resting') {
                            p.effects.pumped = { duration: 10000, end: timestamp + 10000 };
                            createStatusText(p, "PUMPED!", "orange", 2000);
                        }

                        delete p.effects[effectName];
                        applyWeaponStats(p); // Re-apply stats after an effect wears off
                    }
                    if (effectName === 'knockback' && timestamp > effect.end) {
                        delete p.effects[effectName];
                    }
                    if (effectName === 'isAirborne' && timestamp > effect.end) {
                        delete p.effects[effectName];
                    }
                }
            });
            visualEffects = visualEffects.filter(e => timestamp < e.end);
        }

        function handleCollisions() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                if (!proj) continue;

                for (const wall of barriers) {
                    if (wall.team !== proj.team && Math.hypot(proj.x - wall.x, proj.y - wall.y) < wall.width / 2) {
                        wall.health -= proj.damage;
                        projectiles.splice(i, 1);
                        break;
                    }
                }
                if (!projectiles[i]) continue;

                for (const turret of turrets) {
                    if(turret.team !== proj.team && Math.hypot(proj.x - turret.x, proj.y - turret.y) < 18) {
                        turret.health -= proj.damage;
                        projectiles.splice(i,1);
                        break;
                    }
                }
                if(!projectiles[i]) continue;

                for (const player of gameObjects) {
                    if (!player.isAlive || player.team === proj.team || player.effects.rucking || player.effects.charging) continue;

                    if (Math.hypot(proj.x - player.x, proj.y - player.y) < player.radius) {
                        if (proj.isAnnihilation) {
                            player.health = 0;
                            createDamageNumber(player.x, player.y, 9999, 'white');
                        } else {
                            let damageToDeal = proj.damage;
                            if (player.effects.kickVulnerability) damageToDeal *= 1.5;

                            if (player.shield > 0) {
                                const shieldDamage = Math.min(player.shield, damageToDeal);
                                player.shield -= shieldDamage;
                                damageToDeal -= shieldDamage;
                            }
                            player.health = Math.max(0, player.health - damageToDeal);
                            createDamageNumber(player.x, player.y, proj.damage);
                        }

                        player.effects.hitFlash = { end: performance.now() + 100 };
                        if (proj.isAcid) {
                            player.effects.acidDoT = { duration: 15000, end: performance.now() + 15000, lastTick: 0 };
                            acidPuddles.push({x: proj.x, y: proj.y, radius: 30, endTime: performance.now() + 5000});
                        }
                        if (proj.isScissor) {
                            player.effects.regenBlock = true;
                            createStatusText(player, "Healing Blocked!", "purple", 3000);
                            applyWeaponStats(player);
                        }
                        if(player.health <= 0) {
                           player.isAlive = false; player.deaths++;
                           const killer = gameObjects.find(p => p.id === proj.ownerId);
                           if(killer) killer.kills++;
                           player.respawnTimer = performance.now() + 10000;
                           if (player === localPlayer) {
                               respawnScreen.style.display = 'flex';
                               selectNextWeapon(player.weapon);
                           }
                           const carriedPhone = phones.find(g => g.carrier === player);
                           if (carriedPhone) { carriedPhone.carrier = null; carriedPhone.droppedAt = Date.now(); showMessage(`${player.name} dropped the phone!`); }
                        }
                        projectiles.splice(i, 1);
                        break;
                    }
                }
            }
            gameObjects.forEach(player => {
                if (!player.isAlive) return;
                phones.forEach(phone => {
                    if (player.team !== phone.team && !phone.carrier) {
                        if (Math.hypot(player.x - phone.x, player.y - phone.y) < player.radius + phone.size / 2) {
                            phone.carrier = player; phone.droppedAt = 0;
                            player.phonesStolen++;
                            showMessage(`${player.name} picked up Team ${phone.team}'s phone!`);
                        }
                    }
                });
                const carriedPhone = phones.find(g => g.carrier === player);
                if(carriedPhone) {
                    const homeBase = phones.find(g => g.team === player.team);
                    if (Math.hypot(player.x - homeBase.baseX, player.y - homeBase.baseY) < 50) {
                        if(player.team === 'A') {
                            teamAScore++;
                            const scoreEl = document.getElementById('team-a-score');
                            scoreEl.classList.add('score-flash');
                            setTimeout(() => scoreEl.classList.remove('score-flash'), 600);
                        } else {
                            teamBScore++;
                            const scoreEl = document.getElementById('team-b-score');
                            scoreEl.classList.add('score-flash');
                            setTimeout(() => scoreEl.classList.remove('score-flash'), 600);
                        }
                        player.phonesScored++;
                        showMessage(`${player.name} scored for ${player.team === 'A' ? teamAName : teamBName}!`);
                        carriedPhone.carrier = null; carriedPhone.x = carriedPhone.baseX; carriedPhone.y = carriedPhone.baseY; carriedPhone.droppedAt = 0;
                        if(teamAScore >= scoreToWin) endGame(teamAName);
                        else if (teamBScore >= scoreToWin) endGame(teamBName);
                    }
                }
            });
        }

        function endGame(winner) {
            if (gameState === 'gameover') return;
            gameState = 'gameover';
            clearInterval(gameTimerInterval);
            cancelAnimationFrame(animationFrameId);
            document.getElementById('winner-announcement').textContent = `${winner} Wins!`;
            document.getElementById('game-stats').textContent = `Final Score: ${teamAScore} - ${teamBScore}`;
            displayFinalLeaderboard();
            showScreen('gameover');
        }

        function displayFinalLeaderboard() {
            const container = document.getElementById('final-leaderboard-container');

            const generateTeamTable = (team, teamName) => {
                const teamColor = team === 'A' ? TEAM_A_COLOR_HEX : TEAM_B_COLOR_HEX;
                let tableHTML = `
                    <div class="leaderboard-team-panel" style="--team-color: ${teamColor};">
                        <h3>${teamName} - Final Score: ${team === 'A' ? teamAScore : teamBScore}</h3>
                        <table class="leaderboard-table">
                            <thead>
                                <tr>
                                    <th>Player</th>
                                    <th>KDA</th>
                                    <th>Phones Scored</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                const playersInTeam = gameObjects.filter(p => p.team === team).sort((a, b) => b.kills - a.kills);

                playersInTeam.forEach(p => {
                    tableHTML += `
                        <tr>
                            <td>${p.name} ${p.isCaptain ? '👑' : ''}</td>
                            <td>${p.kills}/${p.deaths}/${p.assists}</td>
                            <td>${p.phonesScored}</td>
                        </tr>
                    `;
                });

                tableHTML += `</tbody></table></div>`;
                return tableHTML;
            };

            container.innerHTML = `<div id="leaderboard-container">${generateTeamTable('A', teamAName)} ${generateTeamTable('B', teamBName)}</div>`;
        }

        function draw() {
            const now = performance.now();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if(localPlayer) {
                camera.targetX = localPlayer.x - canvas.width / 2;
                camera.targetY = localPlayer.y - canvas.height / 2;
                camera.x += (camera.targetX - camera.x) * 0.08;
                camera.y += (camera.targetY - camera.y) * 0.08;
                camera.x = Math.max(0, Math.min(camera.x, mapWidth - canvas.width));
                camera.y = Math.max(0, Math.min(camera.y, mapHeight - canvas.height));
            }


            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
            ctx.lineWidth = 1;
            for (let i = 0; i < mapWidth; i += 50) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, mapHeight); ctx.stroke(); }
            for (let i = 0; i < mapHeight; i += 50) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(mapWidth, i); ctx.stroke(); }

            phones.forEach(phone => {
                const isTeamA = phone.team === 'A';
                const teamColor = isTeamA ? 'rgba(240, 77, 93, 0.5)' : 'rgba(0, 184, 212, 0.5)';
                const gradColorStop = isTeamA ? 'rgba(240, 77, 93, 0.3)' : 'rgba(0, 184, 212, 0.3)';

                ctx.beginPath();
                ctx.arc(phone.baseX, phone.baseY, 50, 0, Math.PI * 2);
                const grad = ctx.createRadialGradient(phone.baseX, phone.baseY, 10, phone.baseX, phone.baseY, 50);
                grad.addColorStop(0, gradColorStop);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fill();
                ctx.strokeStyle = teamColor;
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            acidPuddles.forEach(puddle => {
                ctx.fillStyle = "rgba(100, 255, 100, 0.3)";
                ctx.beginPath(); ctx.arc(puddle.x, puddle.y, puddle.radius, 0, Math.PI * 2); ctx.fill();
            });

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy; p.alpha -= 1 / p.lifespan;
                if (p.alpha <= 0) { particles.splice(i, 1); continue; }
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }

            gameObjects.sort((a,b) => a.y - b.y);
            phones.forEach(phone => { if (!phone.carrier) { ctx.font = `${phone.size}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('📱', phone.x, phone.y); }});

            turrets.forEach(turret => {
                const angle = turret.target ? Math.atan2(turret.target.y - turret.y, turret.target.x - turret.x) : (turret.team === 'A' ? 0 : Math.PI);
                ctx.save();
                ctx.translate(turret.x, turret.y);
                const turretColor = turret.team === 'A' ? '#a13326' : '#226a9c';
                ctx.fillStyle = turret.health < (250 * 0.5) ? '#555' : turretColor;
                ctx.beginPath(); ctx.arc(0,0,18, 0, Math.PI*2); ctx.fill();
                ctx.rotate(angle);
                ctx.fillStyle = '#333';
                ctx.fillRect(10, -5, 15, 10);
                ctx.restore();
            });

            barriers.forEach(wall => {
                ctx.save();
                ctx.translate(wall.x, wall.y);
                ctx.rotate(wall.angle);
                ctx.fillStyle = wall.team === 'A' ? 'rgba(240, 77, 93, 0.7)' : 'rgba(0, 184, 212, 0.7)';
                ctx.strokeStyle = wall.team === 'A' ? 'var(--team-a-color)' : 'var(--team-b-color)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.rect(-wall.width / 2, -wall.height / 2, wall.width, wall.height);
                ctx.fill();
                ctx.stroke();
                const barY = -wall.height / 2 - 10;
                ctx.fillStyle = '#333'; ctx.fillRect(-wall.width/2, barY, wall.width, 5);
                const hp = wall.health / wall.maxHealth;
                ctx.fillStyle = hp > 0.6 ? '#2ecc71' : hp > 0.3 ? '#f1c40f' : '#e74c3c';
                ctx.fillRect(-wall.width/2, barY, wall.width * hp, 5);
                ctx.restore();
            });

            visualEffects.forEach(effect => {
                const life = (now - effect.start) / effect.duration;
                const alpha = 1 - life;
                ctx.globalAlpha = alpha > 0 ? alpha : 0;
                if (effect.type === 'kick_burst') {
                    ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 5 * (1 - life); ctx.beginPath();
                    ctx.arc(effect.x, effect.y, 10 + life * 40, 0, Math.PI * 2); ctx.stroke();
                } else if (effect.type === 'trauma') {
                    ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 8 * (1 - life); ctx.beginPath();
                    ctx.arc(effect.x, effect.y, life * 150, 0, Math.PI * 2); ctx.stroke();
                } else if (effect.type === 'destroy_pulse') {
                    ctx.fillStyle = `rgba(192, 57, 43, ${0.5 * alpha})`; ctx.beginPath();
                    ctx.arc(effect.x, effect.y, life * 75, 0, Math.PI * 2); ctx.fill();
                }
                ctx.globalAlpha = 1;
            });

            gameObjects.forEach(obj => {
                if (!obj.isAlive) return;
                const aimTarget = (obj === localPlayer) ? { x: mousePos.x + camera.x, y: mousePos.y + camera.y } : (obj.aiTarget || { x: obj.x + (obj.team === 'A' ? 10 : -10), y: obj.y });
                const aimAngle = Math.atan2(aimTarget.y - obj.y, aimTarget.x - obj.x);

                ctx.save();
                ctx.translate(obj.x, obj.y);

                if (obj.effects.charging) {
                    const chargeAngle = obj.effects.charging.angle;
                    for (let i = 1; i <= 4; i++) {
                        ctx.fillStyle = `rgba(255, 255, 150, ${0.4 - i * 0.1})`; ctx.beginPath();
                        const trailX = -Math.cos(chargeAngle) * i * 10; const trailY = -Math.sin(chargeAngle) * i * 10;
                        if (obj.team === 'A') { ctx.arc(trailX, trailY, obj.radius, 0, Math.PI * 2); }
                        else { ctx.rect(trailX - obj.radius, trailY - obj.radius, obj.radius * 2, obj.radius * 2); }
                        ctx.fill();
                    }
                }
                if (obj.effects.rucking) {
                    const shimmerAlpha = 0.6 + Math.random() * 0.3;
                    ctx.fillStyle = `rgba(180, 180, 190, ${shimmerAlpha})`; ctx.beginPath();
                    ctx.arc(0, 0, obj.radius + 5, 0, Math.PI * 2); ctx.fill();
                }
                if (obj.effects.sprint || obj.effects.pumped) {
                     for (let i = 1; i <= 3; i++) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.3 - i * 0.1})`; ctx.beginPath();
                        const trailX = -Math.cos(aimAngle) * i * 15; const trailY = -Math.sin(aimAngle) * i * 15;
                        if (obj.team === 'A') { ctx.arc(trailX, trailY, obj.radius, 0, Math.PI * 2); }
                        else { ctx.rect(trailX - obj.radius, trailY - obj.radius, obj.radius * 2, obj.radius * 2); }
                        ctx.fill();
                    }
                }
                if (obj.effects.awakened) {
                     ctx.fillStyle = `rgba(255, 0, 0, ${0.3 + Math.random() * 0.2})`; ctx.beginPath();
                     ctx.arc(0,0,obj.radius + 6, 0, Math.PI*2); ctx.fill();
                }
                if (obj.effects.ebola) {
                    ctx.fillStyle = `rgba(46, 139, 87, ${0.4 + Math.random() * 0.2})`; ctx.beginPath();
                    ctx.arc(0,0,obj.radius + 4, 0, Math.PI*2); ctx.fill();
                }
                if (obj.effects.glitched) { ctx.strokeStyle = Math.random() > 0.5 ? 'cyan' : 'magenta'; ctx.lineWidth = 3; ctx.strokeRect(-obj.radius, -obj.radius, obj.radius*2, obj.radius*2); }
                if (obj.effects.pinged && obj !== localPlayer) { ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, obj.radius + 3, 0, Math.PI * 2); ctx.stroke(); }

                const teamColor = obj.team === 'A' ? TEAM_A_COLOR_HEX : TEAM_B_COLOR_HEX;
                ctx.fillStyle = obj.effects.hitFlash && now < obj.effects.hitFlash.end ? '#FFFFFF' : teamColor;

                ctx.beginPath();
                if (obj.team === 'A') ctx.arc(0, 0, obj.radius, 0, Math.PI * 2);
                else ctx.rect(-obj.radius, -obj.radius, obj.radius * 2, obj.radius * 2);

                ctx.shadowColor = teamColor; ctx.shadowBlur = 15;
                ctx.fill();
                ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;

                ctx.font = `${obj.radius * 1.5}px Arial`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(characterClasses[obj.class].icon, 0, 0);

                if (obj.effects.cocoon) { ctx.fillStyle = 'rgba(139, 69, 19, 0.5)'; ctx.beginPath(); ctx.arc(0,0,obj.radius + 8, 0, Math.PI*2); ctx.fill(); }
                if (obj.effects.kickVulnerability) { ctx.strokeStyle = 'rgba(255,100,0,0.8)'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0,0,obj.radius-2,0,Math.PI*2); ctx.stroke(); }

                ctx.rotate(aimAngle);
                ctx.fillStyle = obj.effects.gun ? 'var(--gem-color)' : '#34495e';
                ctx.fillRect(obj.radius / 2, -5, obj.radius, 10);
                ctx.restore();

                const carriedPhone = phones.find(g => g.carrier === obj);
                if (carriedPhone) { ctx.font = '24px Arial'; ctx.fillText('📱', obj.x, obj.y - obj.radius - 20); }

                const barWidth = obj.radius * 2 + 10;
                const barY = obj.y - obj.radius - 12;
                ctx.fillStyle = '#333'; ctx.fillRect(obj.x - barWidth/2, barY, barWidth, 6);
                const hp = obj.health / obj.maxHealth;
                ctx.fillStyle = hp > 0.6 ? '#2ecc71' : hp > 0.3 ? '#f1c40f' : '#e74c3c';
                ctx.fillRect(obj.x - barWidth/2, barY, barWidth * hp, 6);

                if (obj.shield > 0) {
                    const shieldY = barY - 7;
                    ctx.fillStyle = '#333'; ctx.fillRect(obj.x - barWidth/2, shieldY, barWidth, 6);
                    const sp = obj.shield / obj.maxShield;
                    ctx.fillStyle = '#3498db';
                    ctx.fillRect(obj.x - barWidth/2, shieldY, barWidth * sp, 6);
                }
            });

            projectiles.forEach(p => {
                ctx.fillStyle = p.isAcid ? '#7FFF00' : p.isAnnihilation ? 'white' : 'var(--gem-color)';
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
            });

            for (let i = damageNumbers.length - 1; i >= 0; i--) {
                const dn = damageNumbers[i];
                const life = (now - dn.startTime) / 1000;
                if (life > 1) { damageNumbers.splice(i, 1); continue; }
                dn.y -= 0.5; dn.alpha = 1 - life;
                ctx.globalAlpha = dn.alpha;
                ctx.font = 'bold 18px ' + getComputedStyle(document.body).getPropertyValue('--font-main');
                ctx.fillStyle = dn.color; ctx.textAlign = 'center';
                ctx.fillText(dn.text, dn.x, dn.y);
                ctx.globalAlpha = 1;
            }
             for (let i = statusTexts.length - 1; i >= 0; i--) {
                const st = statusTexts[i];
                if (now > st.endTime) { statusTexts.splice(i, 1); continue; }
                const target = gameObjects.find(p => p.id === st.targetId);
                if (target) {
                    ctx.font = 'bold 16px ' + getComputedStyle(document.body).getPropertyValue('--font-main');
                    ctx.fillStyle = st.color; ctx.textAlign = 'center';
                    ctx.fillText(st.text, target.x, target.y - target.radius - 30);
                }
            }


            ctx.restore();
            drawMinimap();

            if (localPlayer && localPlayer.isAlive) {
                const shootCooldownDuration = 1000 / localPlayer.fireRate;
                const timeSinceShot = now - lastShootTime;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 2;
                if (timeSinceShot < shootCooldownDuration) {
                    const progress = timeSinceShot / shootCooldownDuration;
                    ctx.beginPath();
                    ctx.arc(mousePos.x, mousePos.y, 20, -Math.PI / 2, -Math.PI / 2 + progress * 2 * Math.PI, true);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(mousePos.x - 10, mousePos.y); ctx.lineTo(mousePos.x + 10, mousePos.y);
                    ctx.moveTo(mousePos.x, mousePos.y - 10); ctx.lineTo(mousePos.x, mousePos.y + 10);
                    ctx.stroke();
                }
            }
        }

        function drawMinimap() {
            const scaleX = minimapCanvas.width / mapWidth;
            const scaleY = minimapCanvas.height / mapHeight;
            const now = performance.now();

            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            minimapCtx.fillStyle = 'rgba(22, 33, 62, 0.7)';
            minimapCtx.fillRect(0,0, minimapCanvas.width, minimapCanvas.height);

            if (!localPlayer) return;

            gameObjects.forEach(p => {
                if (!p.isAlive) return;
                const minimapX = p.x * scaleX; const minimapY = p.y * scaleY;

                if (p === localPlayer) {
                    minimapCtx.fillStyle = 'yellow';
                    minimapCtx.beginPath(); minimapCtx.arc(minimapX, minimapY, 3, 0, Math.PI * 2); minimapCtx.fill();
                } else if (p.team === localPlayer.team) {
                    minimapCtx.fillStyle = p.team === 'A' ? TEAM_A_COLOR_HEX : TEAM_B_COLOR_HEX;
                    if (p.team === 'A') { minimapCtx.beginPath(); minimapCtx.arc(minimapX, minimapY, 2, 0, Math.PI * 2); minimapCtx.fill(); }
                    else { minimapCtx.fillRect(minimapX - 2, minimapY - 2, 4, 4); }
                } else {
                    if (p.isCurrentlyVisible || p.effects.pinged) {
                        minimapCtx.fillStyle = p.team === 'A' ? TEAM_A_COLOR_HEX : TEAM_B_COLOR_HEX;
                        if (p.team === 'A') { minimapCtx.beginPath(); minimapCtx.arc(minimapX, minimapY, 2, 0, Math.PI * 2); minimapCtx.fill(); }
                        else { minimapCtx.fillRect(minimapX - 2, minimapY - 2, 4, 4); }
                    } else if (p.lastSeenPosition && now - p.lastSeenPosition.timestamp < ENEMY_LINGER_DURATION) {
                        const timeSinceSeen = now - p.lastSeenPosition.timestamp;
                        const alpha = 1 - (timeSinceSeen / ENEMY_LINGER_DURATION);
                        minimapCtx.fillStyle = `rgba(200, 200, 200, ${alpha})`;
                        minimapCtx.font = 'bold 10px Arial';
                        minimapCtx.textAlign = 'center';
                        minimapCtx.textBaseline = 'middle';
                        minimapCtx.fillText('?', p.lastSeenPosition.x * scaleX, p.lastSeenPosition.y * scaleY);
                    }
                }
            });

            phones.forEach(phone => { minimapCtx.fillStyle = 'white'; minimapCtx.beginPath(); minimapCtx.arc(phone.x * scaleX, phone.y * scaleY, 3, 0, Math.PI*2); minimapCtx.fill(); });
            minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(camera.x * scaleX, camera.y * scaleY, canvas.width * scaleX, canvas.height * scaleY);
        }

        function updateGameUI() {
            if (!localPlayer) return;
            // Phone Status UI
            const warningA = document.getElementById('phone-stolen-warning-a');
            const warningB = document.getElementById('phone-stolen-warning-b');
            if (localPlayer.team === 'A') {
                warningA.style.display = teamAPhoneStolen ? 'block' : 'none';
                warningB.style.display = 'none';
            } else if (localPlayer.team === 'B') {
                warningB.style.display = teamBPhoneStolen ? 'block' : 'none';
                warningA.style.display = 'none';
            }

            // Regular UI
            document.getElementById('team-a-score').textContent = teamAScore;
            document.getElementById('team-b-score').textContent = teamBScore;
            const hpEl = document.getElementById('player-hp');
            if (localPlayer.effects.hitFlash && !hpEl.classList.contains('hurt')) {
                hpEl.classList.add('hurt');
                setTimeout(() => hpEl.classList.remove('hurt'), 200);
            }
            hpEl.textContent = `HP: ${Math.ceil(localPlayer.health)}`;
            hpEl.style.setProperty('--hp-percent', `${(localPlayer.health / localPlayer.maxHealth) * 100}%`);
            document.getElementById('player-kda').textContent = `KDA: ${localPlayer.kills}/${localPlayer.deaths}/${localPlayer.assists}`;
            const sortedPlayers = [...gameObjects].sort((a,b) => b.kills - a.kills);
            const rank = sortedPlayers.findIndex(p => p === localPlayer) + 1;
            const rankSuffix = rank === 1 ? 'st' : rank === 2 ? 'nd' : rank === 3 ? 'rd' : 'th';
            document.getElementById('player-rank').textContent = `${rank}${rankSuffix}`;
            updateAbilityUI();
            if (!localPlayer.isAlive) {
                const timeLeft = Math.max(0, (localPlayer.respawnTimer - performance.now()) / 1000).toFixed(1);
                respawnTimerEl.textContent = timeLeft;
            }
        }

        function updateLeaderboard() {
            const container = document.getElementById('leaderboard-container');
            const now = performance.now();

            const generateTeamTable = (team, teamName) => {
                const teamColor = team === 'A' ? 'var(--team-a-color)' : 'var(--team-b-color)';
                let tableHTML = `
                    <div class="leaderboard-team-panel" style="--team-color: ${teamColor};">
                        <h3>${teamName}</h3>
                        <table class="leaderboard-table">
                            <thead>
                                <tr>
                                    <th>Player</th>
                                    <th>KDA</th>
                                    <th>Phones Stolen</th>
                                    <th>Status</th>
                                    ${localPlayer.team === team ? '<th>Abilities (Q/E)</th>' : ''}
                                </tr>
                            </thead>
                            <tbody>
                `;
                const playersInTeam = gameObjects.filter(p => p.team === team);
                playersInTeam.sort((a,b) => b.kills - a.kills);

                playersInTeam.forEach(p => {
                    let status;
                    if (p.isAlive) {
                        status = `HP: ${Math.ceil(p.health)}`;
                    } else {
                        const respawnTime = Math.max(0, (p.respawnTimer - now) / 1000).toFixed(1);
                        status = `<span class="status-dead">Respawn: ${respawnTime}s</span>`;
                    }

                    let abilitiesHTML = '';
                    if (localPlayer.team === team) {
                        const classInfo = characterClasses[p.class];
                        const abilities = classInfo ? classInfo.abilities : ['N/A', 'N/A'];
                        const cd1 = p.ability1Cooldown || 0;
                        const cd2 = p.ability2Cooldown || 0;
                        const ability1Status = now < cd1 ? `<span class="cooldown">${Math.ceil((cd1 - now) / 1000)}s</span>` : `<span class="ready">Rdy</span>`;
                        const ability2Status = now < cd2 ? `<span class="cooldown">${Math.ceil((cd2 - now) / 1000)}s</span>` : `<span class="ready">Rdy</span>`;

                        abilitiesHTML = `<td class="ally-ability">${ability1Status} / ${ability2Status}</td>`;
                    }

                    tableHTML += `
                        <tr>
                            <td>${p.name} ${p.isCaptain ? '👑' : ''}</td>
                            <td>${p.kills}/${p.deaths}/${p.assists}</td>
                            <td>${p.phonesStolen}</td>
                            <td>${status}</td>
                            ${abilitiesHTML}
                        </tr>
                    `;
                });

                tableHTML += `</tbody></table></div>`;
                return tableHTML;
            };

            container.innerHTML = generateTeamTable('A', teamAName) + generateTeamTable('B', teamBName);
        }

        function updateTimer() {
            if (gameState !== 'gameplay') return;
            gameTime--;
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            document.getElementById('game-timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            if (gameTime <= 0) {
                endGame(teamAScore > teamBScore ? teamAName : teamAScore < teamBScore ? teamBName : "Nobody");
            }
        }

        function activateAbility(player, slot) {
             if (!player || !player.isAlive || !player.class) return;
            const now = performance.now();
            const abilityName = characterClasses[player.class].abilities[slot];
            const cooldownProp = slot === 0 ? 'ability1Cooldown' : 'ability2Cooldown';
            if (now < (player[cooldownProp] || 0)) return;

            let cooldown = abilityCooldowns[abilityName] * 1000;
            let abilityUsed = true;

            switch(abilityName) {
                case 'Ruck': player.effects.rucking = { duration: 5000, end: now + 5000 }; showMessage(`You became immune!`); break;
                case 'Charge':
                    const aimTargetCharge = (player === localPlayer) ? { x: mousePos.x + camera.x, y: mousePos.y + camera.y } : { x: player.x + (player.team === 'A' ? 1 : -1), y: player.y };
                    const angleCharge = Math.atan2(aimTargetCharge.y - player.y, aimTargetCharge.x - player.x);
                    player.effects.charging = { duration: 750, end: now + 750, angle: angleCharge };
                    showMessage(`You are charging!`);
                    break;
                case 'Sprint': player.effects.sprint = { duration: 5000, end: now + 5000 }; applyWeaponStats(player); break;
                case 'Kick':
                    const kickTarget = gameObjects.find(p => p.isAlive && p.team !== player.team && Math.hypot(p.x - player.x, p.y - player.y) < 50);
                    if (kickTarget) {
                        kickTarget.health = Math.max(0, kickTarget.health - 80);
                        createDamageNumber(kickTarget.x, kickTarget.y, 80);
                        player.health = 1;
                        player.effects.kickVulnerability = { duration: 5000, end: now + 5000 };
                        createStatusText(player, "Vulnerable!", '#e67e22', 5000);
                        visualEffects.push({ type: 'kick_burst', x: player.x, y: player.y, duration: 300, start: now, end: now + 300 });
                        if (player === localPlayer) showMessage(`Risky move! Your health is now 1.`);
                    } else { abilityUsed = false; }
                    break;
                case 'Trauma':
                    gameObjects.forEach(p => {
                        if (p.isAlive && p.team !== player.team && Math.hypot(p.x-player.x, p.y-player.y) < 150) {
                            p.effects.traumatized = { duration: 3000, end: now + 3000 };
                            createStatusText(p, "Stunned!", '#f1c40f', 3000);
                        }
                    });
                    visualEffects.push({ type: 'trauma', x: player.x, y: player.y, duration: 500, start: now, end: now + 500 });
                    break;
                case 'Destroy':
                    turrets = turrets.filter(t => Math.hypot(t.x - player.x, t.y - player.y) >= 75);
                    barriers = barriers.filter(b => Math.hypot(b.x - player.x, b.y - player.y) >= 75);
                    visualEffects.push({ type: 'destroy_pulse', x: player.x, y: player.y, duration: 400, start: now, end: now + 400 });
                    break;
                case 'Turret':
                    turrets.push({ x: player.x, y: player.y, health: 500, team: player.team, damage: 8, fireRate: 0.6, lastShotTime: 0, target: null });
                    break;
                case 'Wall':
                    const aimTargetBarrier = (player === localPlayer) ? { x: mousePos.x + camera.x, y: mousePos.y + camera.y } : (player.aiTarget || {x: player.x + 1, y: player.y});
                    const angleBarrier = Math.atan2(aimTargetBarrier.y - player.y, aimTargetBarrier.x - player.x);
                    barriers.push({
                        x: player.x + Math.cos(angleBarrier) * 50,
                        y: player.y + Math.sin(angleBarrier) * 50,
                        width: 72, height: 20, angle: angleBarrier, team: player.team, health: 1000, maxHealth: 1000
                    });
                    abilityUsed = true;
                    break;
                case 'Gun': player.effects.gun = { duration: 20000, end: now + 20000 }; applyWeaponStats(player); break;
                case 'Cocoon': player.maxHealth += 500; player.health += 500; player.effects.cocoon = { duration: 10000, end: now + 10000 }; applyWeaponStats(player); break;
                case 'Ping': gameObjects.forEach(p => { if (p.team !== player.team) p.effects.pinged = { duration: 2000, end: now + 2000 }; }); break;
                case 'Glitch':
                    let closest = null, minDist = 100;
                    gameObjects.forEach(p => { if (p !== player && p.isAlive && p.team === player.team) { const d = Math.hypot(p.x-player.x,p.y-player.y); if(d<minDist){minDist=d;closest=p;}}});
                    if (closest && !closest.effects.glitched) {
                        closest.maxHealth *= 2; closest.health *= 2;
                        closest.effects.glitched = true;
                        applyWeaponStats(closest);
                        if (player === localPlayer) showMessage(`${player.name} glitched ${closest.name}!`);
                    } else { abilityUsed = false; }
                    break;
                case 'Annihilation':
                    const target = (player === localPlayer) ? { x: mousePos.x + camera.x, y: mousePos.y + camera.y } : player.aiTarget;
                    if (target) createProjectile(player, target, 'annihilation');
                    else abilityUsed = false;
                    break;
                case 'Ebola':
                    let closestEbolaTarget = null, minEbolaDist = 150;
                    gameObjects.forEach(p => { if (p.isAlive && p.team !== player.team) { const d = Math.hypot(p.x-player.x,p.y-player.y); if(d<minEbolaDist){minEbolaDist=d;closestEbolaTarget=p;}}});
                    if (closestEbolaTarget && !closestEbolaTarget.effects.ebola) {
                        closestEbolaTarget.effects.ebola = { lastTick: 0 };
                        createStatusText(closestEbolaTarget, "INFECTED", "#2e8b57", 2000);
                    } else { abilityUsed = false; }
                    break;
                case 'Curl':
                    let closestCurlTarget = null, minCurlDist = 100;
                    gameObjects.forEach(p => { if (p.isAlive && p.team !== player.team) { const d = Math.hypot(p.x-player.x,p.y-player.y); if(d<minCurlDist){minCurlDist=d;closestCurlTarget=p;}}});
                    if (closestCurlTarget) {
                         const angle = Math.atan2(closestCurlTarget.y - player.y, closestCurlTarget.x - player.x);
                         closestCurlTarget.effects.isAirborne = { duration: 1000, end: now + 1000, angle: angle, speed: 20 };
                         player.effects.damageDown = { duration: 15000, end: now + 15000 };
                         applyWeaponStats(player);
                    } else { abilityUsed = false; }
                    break;
                case 'Rest':
                    player.effects.resting = { duration: 3000, end: now + 3000 };
                    createStatusText(player, "Resting...", "cyan", 3000);
                    break;
                case 'Awaken':
                    if (player.health < player.maxHealth * 0.5) {
                        player.effects.awakened = true;
                        player.maxHealth *= 2.5;
                        player.health = player.maxHealth;
                        applyWeaponStats(player);
                        createStatusText(player, "AWAKENED!", "red", 5000);
                    } else {
                        showMessage("Health must be below 50% to use Awaken!");
                        abilityUsed = false;
                    }
                    break;
                case 'Help': showMessage("This ability is not yet implemented."); abilityUsed = false; break;
            }
            if (abilityUsed) {
                player[cooldownProp] = now + cooldown;
            }
        }

        function updateAbilityUI() {
             if (!localPlayer || !localPlayer.class) return;
            const classInfo = characterClasses[localPlayer.class];
            const ability1Slot = document.getElementById('ability-1'), ability2Slot = document.getElementById('ability-2');
            ability1Slot.querySelector('.ability-icon').textContent = abilityInfo[classInfo.abilities[0]].icon;
            ability2Slot.querySelector('.ability-icon').textContent = abilityInfo[classInfo.abilities[1]].icon;
            const now = performance.now();
            const cd1 = localPlayer.ability1Cooldown || 0, cd2 = localPlayer.ability2Cooldown || 0;
            if (now < cd1) { ability1Slot.classList.add('on-cooldown'); ability1Slot.querySelector('.cooldown-overlay').textContent = Math.ceil((cd1 - now) / 1000); } else { ability1Slot.classList.remove('on-cooldown'); }
            if (now < cd2) { ability2Slot.classList.add('on-cooldown'); ability2Slot.querySelector('.cooldown-overlay').textContent = Math.ceil((cd2 - now) / 1000); } else { ability2Slot.classList.remove('on-cooldown'); }
        }

        // --- Initializer ---
        function init() {
            resizeCanvas();
            setupEventListeners();
        }

        init();
    </script>
</body>
</html>